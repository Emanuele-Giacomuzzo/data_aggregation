if (TP[loop[1]]>TP[loop[2]]){
G <- delete_edges(G,"loop[1]|loop[2]")
} else {
G <- delete_edges(G,"loop[2]|loop[1]")
}
} else { #If the TP of the two nodes is similar
if (fromone>fromtwo){
edges_string_one <- paste(loop[2],loop[1], sep="|")
G <- delete_edges(G,edges_string_one)
} else {
edges_string_two <- paste(loop[1],loop[2], sep="|")
G <- delete_edges(G,edges_string_two)
}
}
}
}
fromone
fromtwo
fromone <- get.edge.ids(G, c(loop[1],loop[2]), directed = TRUE, error = FALSE, multi = FALSE)  #Get the ID of an edge
fromone <- edge_attr(G,"weight", index = fromone) #Get the weight of an edge
fromtwo <- get.edge.ids(G, c(loop[2],loop[1]), directed = TRUE, error = FALSE, multi = FALSE)  #Get the ID of an edge
rm(list = ls()); cat("\014"); setwd('/Users/ema/Github/Data_aggregation/R_files')
edge_list <- read.delim('../data/edge_list_for_R.txt', header = FALSE)
membership <- read.csv('../variables/membership.txt',header = FALSE)
TP <- as.matrix(read.csv('../variables/TP.txt', header = FALSE))
#Original food web
links <- edge_list %>% select(V1,V2)
weights <- edge_list %>% select(V3)
G <- graph_from_edgelist(as.matrix(links)) #You need to invert i and j
E(G)$weight <- as.matrix(weights)
V(G)$TP <- TP[,1]
G <- simplify(G)
Cycles <- findCycles(G)
source("findCycles.r")
G <- simplify(G)
Cycles <- findCycles(G)
for (i in 1:length(Cycles)){
loop <- unlist(Cycles[i], use.names=FALSE)
fromone <- get.edge.ids(G, c(loop[1],loop[2]), directed = TRUE, error = FALSE, multi = FALSE)  #Get the ID of an edge
fromone <- edge_attr(G,"weight", index = fromone) #Get the weight of an edge
fromtwo <- get.edge.ids(G, c(loop[2],loop[1]), directed = TRUE, error = FALSE, multi = FALSE)  #Get the ID of an edge
fromtwo <- edge_attr(G,"weight", index = fromtwo) #Get the weight of an edge
if (length(loop) == 3) { #If the loop is between two nodes
if (abs(TP[loop[1]]-TP[loop[2]])>0.2*max(TP)){ #If the TP of the two nodes is way different
if (TP[loop[1]]>TP[loop[2]]){
G <- delete_edges(G,"loop[1]|loop[2]")
} else {
G <- delete_edges(G,"loop[2]|loop[1]")
}
} else { #If the TP of the two nodes is similar
if (fromone>fromtwo){
edges_string_one <- paste(loop[2],loop[1], sep="|")
G <- delete_edges(G,edges_string_one)
} else {
edges_string_two <- paste(loop[1],loop[2], sep="|")
G <- delete_edges(G,edges_string_two)
}
}
}
}
rm(list = ls()); cat("\014"); setwd('/Users/ema/Github/Data_aggregation/R_files')
library(ggplot2)
library(tibble)
library(plyr)
library(igraph)
library(NetIndices)
library(dplyr)
edge_list <- read.delim('../data/edge_list_for_R.txt', header = FALSE)
membership <- read.csv('../variables/membership.txt',header = FALSE)
TP <- as.matrix(read.csv('../variables/TP.txt', header = FALSE))
rm(list = ls()); cat("\014"); setwd('/Users/ema/Github/Data_aggregation/R_files')
library(ggplot2)
library(tibble)
library(plyr)
library(igraph)
library(NetIndices)
library(dplyr)
edge_list <- read.delim('../data/edge_list_for_R.txt', header = FALSE)
membership <- read.csv('../variables/membership.txt',header = FALSE)
TP <- as.matrix(read.csv('../variables/TP.txt', header = FALSE))
#Original food web
links <- edge_list %>% select(V1,V2)
weights <- edge_list %>% select(V3)
G <- graph_from_edgelist(as.matrix(links)) #You need to invert i and j
E(G)$weight <- as.matrix(weights)
V(G)$TP <- TP[,1]
source("findCycles.r")
G <- simplify(G)
Cycles <- findCycles(G)
i=1
loop <- unlist(Cycles[i], use.names=FALSE)
fromone <- get.edge.ids(G, c(loop[1],loop[2]), directed = TRUE, error = FALSE, multi = FALSE)  #Get the ID of an edge
fromone <- get.edge.ids(G, c(loop[1],loop[2]), directed = TRUE, error = FALSE, multi = FALSE)  #Get the ID of an edge
fromone <- edge_attr(G,"weight", index = fromone) #Get the weight of an edge
fromone <- get.edge.ids(G, c(loop[1],loop[2]), directed = TRUE, error = FALSE, multi = FALSE)  #Get the ID of an edge
fromone <- edge_attr(G,"weight", index = fromone) #Get the weight of an edge
fromtwo <- get.edge.ids(G, c(loop[2],loop[1]), directed = TRUE, error = FALSE, multi = FALSE)  #Get the ID of an edge
fromone <- get.edge.ids(G, c(loop[1],loop[2]), directed = TRUE, error = FALSE, multi = FALSE)  #Get the ID of an edge
fromone <- edge_attr(G,"weight", index = fromone) #Get the weight of an edge
fromtwo <- get.edge.ids(G, c(loop[2],loop[1]), directed = TRUE, error = FALSE, multi = FALSE)  #Get the ID of an edge
fromtwo <- edge_attr(G,"weight", index = fromtwo) #Get the weight of an edge
loop
length(loop)
if (abs(TP[loop[1]]-TP[loop[2]])>0.2*max(TP)){ #If the TP of the two nodes is way different
if (TP[loop[1]]>TP[loop[2]]){
G <- delete_edges(G,"loop[1]|loop[2]")
} else {
G <- delete_edges(G,"loop[2]|loop[1]")
}
} else { #If the TP of the two nodes is similar
if (fromone>fromtwo){
edges_string_one <- paste(loop[2],loop[1], sep="|")
G <- delete_edges(G,edges_string_one)
} else {
edges_string_two <- paste(loop[1],loop[2], sep="|")
G <- delete_edges(G,edges_string_two)
}
}
rm(list = ls()); cat("\014"); setwd('/Users/ema/Github/Data_aggregation/R_files')
library(ggplot2)
library(tibble)
library(plyr)
library(igraph)
library(NetIndices)
library(dplyr)
edge_list <- read.delim('../data/edge_list_for_R.txt', header = FALSE)
membership <- read.csv('../variables/membership.txt',header = FALSE)
TP <- as.matrix(read.csv('../variables/TP.txt', header = FALSE))
#Original food web
links <- edge_list %>% select(V1,V2)
weights <- edge_list %>% select(V3)
G <- graph_from_edgelist(as.matrix(links)) #You need to invert i and j
E(G)$weight <- as.matrix(weights)
V(G)$TP <- TP[,1]
source("findCycles.r")
G <- simplify(G)
Cycles <- findCycles(G)
for (i in 1:length(Cycles)){
loop <- unlist(Cycles[i], use.names=FALSE)
if (length(loop) == 3) { #If the loop is between two nodes
fromone <- get.edge.ids(G, c(loop[1],loop[2]), directed = TRUE, error = FALSE, multi = FALSE)  #Get the ID of an edge
fromone <- edge_attr(G,"weight", index = fromone) #Get the weight of an edge
fromtwo <- get.edge.ids(G, c(loop[2],loop[1]), directed = TRUE, error = FALSE, multi = FALSE)  #Get the ID of an edge
fromtwo <- edge_attr(G,"weight", index = fromtwo) #Get the weight of an edge
if (abs(TP[loop[1]]-TP[loop[2]])>0.2*max(TP)){ #If the TP of the two nodes is way different
if (TP[loop[1]]>TP[loop[2]]){
G <- delete_edges(G,"loop[1]|loop[2]")
} else {
G <- delete_edges(G,"loop[2]|loop[1]")
}
} else { #If the TP of the two nodes is similar
if (fromone>fromtwo){
edges_string_one <- paste(loop[2],loop[1], sep="|")
G <- delete_edges(G,edges_string_one)
} else {
edges_string_two <- paste(loop[1],loop[2], sep="|")
G <- delete_edges(G,edges_string_two)
}
}
}
}
View(Cycles)
rm(list = ls()); cat("\014"); setwd('/Users/ema/Github/Data_aggregation/R_files')
edge_list <- read.delim('../data/edge_list_for_R.txt', header = FALSE)
membership <- read.csv('../variables/membership.txt',header = FALSE)
TP <- as.matrix(read.csv('../variables/TP.txt', header = FALSE))
#Original food web
links <- edge_list %>% select(V1,V2)
weights <- edge_list %>% select(V3)
G <- graph_from_edgelist(as.matrix(links)) #You need to invert i and j
E(G)$weight <- as.matrix(weights)
V(G)$TP <- TP[,1]
G <- simplify(G)
Cycles <- findCycles(G)
source("findCycles.r")
G <- simplify(G)
Cycles <- findCycles(G)
View(Cycles)
for (i in 1:length(Cycles)){
loop <- unlist(Cycles[i], use.names=FALSE)
if (length(loop) == 3) { #If the loop is between two nodes
fromone <- get.edge.ids(G, c(loop[1],loop[2]), directed = TRUE, error = FALSE, multi = FALSE)  #Get the ID of an edge
fromone <- edge_attr(G,"weight", index = fromone) #Get the weight of an edge
fromtwo <- get.edge.ids(G, c(loop[2],loop[1]), directed = TRUE, error = FALSE, multi = FALSE)  #Get the ID of an edge
fromtwo <- edge_attr(G,"weight", index = fromtwo) #Get the weight of an edge
if (fromone != 0 & fromtwo != 0) {
if (abs(TP[loop[1]]-TP[loop[2]])>0.2*max(TP)){ #If the TP of the two nodes is way different
if (TP[loop[1]]>TP[loop[2]]){
G <- delete_edges(G,"loop[1]|loop[2]")
} else {
G <- delete_edges(G,"loop[2]|loop[1]")
}
} else { #If the TP of the two nodes is similar
if (fromone>fromtwo){
edges_string_one <- paste(loop[2],loop[1], sep="|")
G <- delete_edges(G,edges_string_one)
} else {
edges_string_two <- paste(loop[1],loop[2], sep="|")
G <- delete_edges(G,edges_string_two)
}
}
}
}
}
for (i in 1:length(Cycles)){
loop <- unlist(Cycles[i], use.names=FALSE)
if (length(loop) == 3) { #If the loop is between two nodes
fromone <- get.edge.ids(G, c(loop[1],loop[2]), directed = TRUE, error = FALSE, multi = FALSE)  #Get the ID of an edge
fromone <- edge_attr(G,"weight", index = fromone) #Get the weight of an edge
fromtwo <- get.edge.ids(G, c(loop[2],loop[1]), directed = TRUE, error = FALSE, multi = FALSE)  #Get the ID of an edge
fromtwo <- edge_attr(G,"weight", index = fromtwo) #Get the weight of an edge
if (fromone>0 & fromtwo>0) {
if (abs(TP[loop[1]]-TP[loop[2]])>0.2*max(TP)){ #If the TP of the two nodes is way different
if (TP[loop[1]]>TP[loop[2]]){
G <- delete_edges(G,"loop[1]|loop[2]")
} else {
G <- delete_edges(G,"loop[2]|loop[1]")
}
} else { #If the TP of the two nodes is similar
if (fromone>fromtwo){
edges_string_one <- paste(loop[2],loop[1], sep="|")
G <- delete_edges(G,edges_string_one)
} else {
edges_string_two <- paste(loop[1],loop[2], sep="|")
G <- delete_edges(G,edges_string_two)
}
}
}
}
}
length(fromtwo)
for (i in 1:length(Cycles)){
loop <- unlist(Cycles[i], use.names=FALSE)
if (length(loop) == 3) { #If the loop is between two nodes
fromone <- get.edge.ids(G, c(loop[1],loop[2]), directed = TRUE, error = FALSE, multi = FALSE)  #Get the ID of an edge
fromone <- edge_attr(G,"weight", index = fromone) #Get the weight of an edge
fromtwo <- get.edge.ids(G, c(loop[2],loop[1]), directed = TRUE, error = FALSE, multi = FALSE)  #Get the ID of an edge
fromtwo <- edge_attr(G,"weight", index = fromtwo) #Get the weight of an edge
if (length(fromone)==1 & length(fromtwo)==1) {
if (abs(TP[loop[1]]-TP[loop[2]])>0.2*max(TP)){ #If the TP of the two nodes is way different
if (TP[loop[1]]>TP[loop[2]]){
G <- delete_edges(G,"loop[1]|loop[2]")
} else {
G <- delete_edges(G,"loop[2]|loop[1]")
}
} else { #If the TP of the two nodes is similar
if (fromone>fromtwo){
edges_string_one <- paste(loop[2],loop[1], sep="|")
G <- delete_edges(G,edges_string_one)
} else {
edges_string_two <- paste(loop[1],loop[2], sep="|")
G <- delete_edges(G,edges_string_two)
}
}
}
}
}
Cycles <- findCycles(G)
View(Cycles)
E(G)
length(E(G))
edge_list <- read.delim('../data/edge_list_for_R.txt', header = FALSE)
membership <- read.csv('../variables/membership.txt',header = FALSE)
TP <- as.matrix(read.csv('../variables/TP.txt', header = FALSE))
#Original food web
links <- edge_list %>% select(V1,V2)
weights <- edge_list %>% select(V3)
G <- graph_from_edgelist(as.matrix(links)) #You need to invert i and j
E(G)$weight <- as.matrix(weights)
V(G)$TP <- TP[,1]
rm(list = ls()); cat("\014"); setwd('/Users/ema/Github/Data_aggregation/R_files')
edge_list <- read.delim('../data/edge_list_for_R.txt', header = FALSE)
membership <- read.csv('../variables/membership.txt',header = FALSE)
TP <- as.matrix(read.csv('../variables/TP.txt', header = FALSE))
edge_list <- read.delim('../data/edge_list_for_R.txt', header = FALSE)
membership <- read.csv('../variables/membership.txt',header = FALSE)
TP <- as.matrix(read.csv('../variables/TP.txt', header = FALSE))
#Original food web
links <- edge_list %>% select(V1,V2)
weights <- edge_list %>% select(V3)
G <- graph_from_edgelist(as.matrix(links)) #You need to invert i and j
E(G)$weight <- as.matrix(weights)
V(G)$TP <- TP[,1]
G <- simplify(G)
G <- simplify(G)
Cycles <- findCycles(G)
rm(list = ls()); cat("\014"); setwd('/Users/ema/Github/Data_aggregation/R_files')
rm(list = ls()); cat("\014"); setwd('/Users/ema/Github/Data_aggregation/R_files')
library(ggplot2)
library(tibble)
library(plyr)
library(igraph)
library(NetIndices)
library(dplyr)
edge_list <- read.delim('../data/edge_list_for_R.txt', header = FALSE)
links <- edge_list %>% select(V1,V2)
weights <- edge_list %>% select(V3)
G <- graph_from_edgelist(as.matrix(links)) #You need to invert i and j
E(G)$weight <- as.matrix(weights)
TP <- as.matrix(read.csv('../variables/TP.txt', header = FALSE))
V(G)$TP <- TP[,1]
#membership <- read.csv('../variables/membership.txt',header = FALSE)
source("findCycles.r")
#edge_list <- read.delim('../data/edge_list_for_R.txt', header = FALSE) #Import the edge list. This needs to be of a weighted food web!
#TP <- as.matrix(read.csv('../variables/TP.txt', header = FALSE)) #Import the trophic position (or similar index) of the nodes. It needs to be calculated in advance.
#links <- edge_list %>% select(V1,V2)
#weights <- edge_list %>% select(V3)
#G <- graph_from_edgelist(as.matrix(links)) #You need to invert i and j
#E(G)$weight <- as.matrix(weights)
#V(G)$TP <- TP
G <- simplify(G)
Cycles <- findCycles(G)
View(Cycles)
source("findCycles.r")
#edge_list <- read.delim('../data/edge_list_for_R.txt', header = FALSE) #Import the edge list. This needs to be of a weighted food web!
#TP <- as.matrix(read.csv('../variables/TP.txt', header = FALSE)) #Import the trophic position (or similar index) of the nodes. It needs to be calculated in advance.
#links <- edge_list %>% select(V1,V2)
#weights <- edge_list %>% select(V3)
#G <- graph_from_edgelist(as.matrix(links)) #You need to invert i and j
#E(G)$weight <- as.matrix(weights)
#V(G)$TP <- TP
G <- simplify(G)
Cycles <- findCycles(G)
View(Cycles)
for (i in 1:length(Cycles)){
loop <- unlist(Cycles[i], use.names=FALSE)
if (length(loop) == 3) { #If the loop is between two nodes
fromone <- get.edge.ids(G, c(loop[1],loop[2]), directed = TRUE, error = FALSE, multi = FALSE)  #Get the ID of an edge
fromone <- edge_attr(G,"weight", index = fromone) #Get the weight of an edge
fromtwo <- get.edge.ids(G, c(loop[2],loop[1]), directed = TRUE, error = FALSE, multi = FALSE)  #Get the ID of an edge
fromtwo <- edge_attr(G,"weight", index = fromtwo) #Get the weight of an edge
if (length(fromone)==1 & length(fromtwo)==1) {
if (abs(TP[loop[1]]-TP[loop[2]])>0.2*max(TP)){ #If the TP of the two nodes is way different
if (TP[loop[1]]>TP[loop[2]]){
G <- delete_edges(G,"loop[1]|loop[2]")
} else {
G <- delete_edges(G,"loop[2]|loop[1]")
}
} else { #If the TP of the two nodes is similar
if (fromone>fromtwo){
edges_string_one <- paste(loop[2],loop[1], sep="|")
G <- delete_edges(G,edges_string_one)
} else {
edges_string_two <- paste(loop[1],loop[2], sep="|")
G <- delete_edges(G,edges_string_two)
}
}
}
}
}
length(E(G))
View(edge_list)
View(Cycles)
loop[1]
loop[2]
Cycles[1]
Cycles[2]
Cycles[3]
length(Cycles[3])
length(Cycles[2])
hey <- Cycles[3]
length(hey)
hey
length(loop)
loop <- unlist(Cycles[4], use.names=FALSE)
lenght(loop)
length(loop)
View(Cycles)
rm(list = ls()); cat("\014"); setwd('/Users/ema/Github/Data_aggregation/R_files')
edge_list <- read.delim('../data/edge_list_for_R.txt', header = FALSE)
links <- edge_list %>% select(V1,V2)
weights <- edge_list %>% select(V3)
G <- graph_from_edgelist(as.matrix(links)) #You need to invert i and j
E(G)$weight <- as.matrix(weights)
TP <- as.matrix(read.csv('../variables/TP.txt', header = FALSE))
V(G)$TP <- TP[,1]
length(E(G))
library(dplyr)
source("findCycles.r")
#edge_list <- read.delim('../data/edge_list_for_R.txt', header = FALSE) #Import the edge list. This needs to be of a weighted food web!
#TP <- as.matrix(read.csv('../variables/TP.txt', header = FALSE)) #Import the trophic position (or similar index) of the nodes. It needs to be calculated in advance.
#links <- edge_list %>% select(V1,V2)
#weights <- edge_list %>% select(V3)
#G <- graph_from_edgelist(as.matrix(links)) #You need to invert i and j
#E(G)$weight <- as.matrix(weights)
#V(G)$TP <- TP
G <- simplify(G)
Cycles <- findCycles(G)
View(Cycles)
G <- simplify(G)
Cycles <- findCycles(G)
length(E(G))
for (i in 1:length(Cycles)){
loop <- unlist(Cycles[i], use.names=FALSE)
if (length(loop) == 3) { #If the loop is between two nodes
fromone <- get.edge.ids(G, c(loop[1],loop[2]), directed = TRUE, error = FALSE, multi = FALSE)  #Get the ID of an edge
fromone <- edge_attr(G,"weight", index = fromone) #Get the weight of an edge
fromtwo <- get.edge.ids(G, c(loop[2],loop[1]), directed = TRUE, error = FALSE, multi = FALSE)  #Get the ID of an edge
fromtwo <- edge_attr(G,"weight", index = fromtwo) #Get the weight of an edge
if (length(fromone)==1 & length(fromtwo)==1) {
if (abs(TP[loop[1]]-TP[loop[2]])>0.2*max(TP)){ #If the TP of the two nodes is way different
if (TP[loop[1]]>TP[loop[2]]){
G <- delete_edges(G,"loop[1]|loop[2]")
} else {
G <- delete_edges(G,"loop[2]|loop[1]")
}
} else { #If the TP of the two nodes is similar
if (fromone>fromtwo){
edges_string_one <- paste(loop[2],loop[1], sep="|")
G <- delete_edges(G,edges_string_one)
} else {
edges_string_two <- paste(loop[1],loop[2], sep="|")
G <- delete_edges(G,edges_string_two)
}
}
}
}
}
Cycles <- findCycles(G)
length(E(G))
write_graph(G,"try.txt", format = "edgelist")
as_edgelist(G)
> cbind( get.edgelist(G) , round( E(G)$weight, 3 ))
> cbind( get.edgelist(G) , E(G)$weight)
>get.edgelist(G)
> cbind(as_edgelist(G) , E(G)$weight)
cbind( get.edgelist(G) , round( E(G)$weight, 3 ))
View(edge_list)
cbind( get.edgelist(G) , round( E(G)$weight, 5 ))
cbind( get.edgelist(G) , E(G)$weight )
cbind( get.edgelist(G) , E(G)$weight )
loopless_edge_list <- cbind( get.edgelist(G) , E(G)$weight )
r <- 1
r
z = 2
z
list.files()
list.files( path="../data/ewe_networks" )
temp <- list.files( path="../data/ewe_networks" )
myfiles <- lapply(temp, read.delim)
temp <- list.files( path="../data/ewe_networks" )
myfiles <- lapply(temp, read.delim)
myfiles <- lapply(temp, path="../data/ewe_networks", read.delim)
temp <- list.files(pattern=".txt",path="../data/ewe_networks")
setwd('../data/ewe_networks') #Change working directory
temp <- list.files(pattern=".txt",)
myfiles <- lapply(temp, read.delim)
View(myfiles)
networks <- lapply(temp, read.delim)
View(networks)
whatever <- networks[1]
View(whatever)
whatever <- networks[[1]]
View(whatever)
Cycles <- findCycles(G)
typeof(loopless_edge_list)
write.matrix
write.matrix(loopless_edge_list)
n <- 1
file_name <- paste("loopless",n)
file_name <- paste("loopless",n,".txt")
file_name <- paste0("loopless",n,".txt")
View(networks)
temp <- list.files(pattern="edge_list.txt",)
temp <- list.files(pattern="TP.txt")
temp <- list.files(pattern="edge_list.txt")
#This part of the code imports multiple food webs all at once. Skip it if you are working with a single food web.
setwd('../data/ewe_networks') #Select the folder where the files are saved.
temp <- list.files(pattern="edge_list.txt")
networks <- lapply(temp, read.delim)
temp <- list.files(pattern="TP.txt")
TP <- lapply(temp, read.delim)
for (n in 1:length(networks)){
edge_list <- networks[[n]]
TP <- TP [[n]]
links <- edge_list %>% select(V1,V2)
weights <- edge_list %>% select(V3)
G <- graph_from_edgelist(as.matrix(links)) #You need to invert i and j
E(G)$weight <- as.matrix(weights)
V(G)$TP <- TP
G <- simplify(G)
Cycles <- findCycles(G)
for (i in 1:length(Cycles)){
loop <- unlist(Cycles[i], use.names=FALSE)
if (length(loop) == 3) { #If the loop is between two nodes
fromone <- get.edge.ids(G, c(loop[1],loop[2]), directed = TRUE, error = FALSE, multi = FALSE)  #Get the ID of an edge
fromone <- edge_attr(G,"weight", index = fromone) #Get the weight of an edge
fromtwo <- get.edge.ids(G, c(loop[2],loop[1]), directed = TRUE, error = FALSE, multi = FALSE)  #Get the ID of an edge
fromtwo <- edge_attr(G,"weight", index = fromtwo) #Get the weight of an edge
if (length(fromone)==1 & length(fromtwo)==1) {
if (abs(TP[loop[1]]-TP[loop[2]])>0.2*max(TP)){ #If the TP of the two nodes is way different
if (TP[loop[1]]>TP[loop[2]]){
G <- delete_edges(G,"loop[1]|loop[2]")
} else {
G <- delete_edges(G,"loop[2]|loop[1]")
}
} else { #If the TP of the two nodes is similar
if (fromone>fromtwo){
edges_string_one <- paste(loop[2],loop[1], sep="|")
G <- delete_edges(G,edges_string_one)
} else {
edges_string_two <- paste(loop[1],loop[2], sep="|")
G <- delete_edges(G,edges_string_two)
}
}
}
}
}
loopless_edge_list <- cbind( get.edgelist(G) , E(G)$weight )
file_name <- paste0("loopless",n,".txt")
write.matrix( loopless_edge_list, file="file_name", sep = "\t" )
}
